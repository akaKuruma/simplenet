#!/usr/bin/python

# Copyright 2012 Locaweb.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.
#
# @author: Juliano Martinez (ncode), Locaweb.
# @author: Luiz Ozaki, Locaweb.
# @author: Eduardo S. Scarpellini, Locaweb.

import ConfigParser
import difflib
import getopt
import hashlib
import json
import logging
import os
import re
import sys

from datetime import datetime
from ipaddr import IPNetwork
from lockfile import FileLock
from supay import Daemon

from kombu import Exchange, Queue
from kombu import BrokerConnection
from kombu.mixins import ConsumerMixin
from kombu.utils.debug import setup_logging


setup_logging(loglevel="INFO")
LOGGING_LEVELS = {'critical': logging.CRITICAL,
                  'error': logging.ERROR,
                  'warning': logging.WARNING,
                  'info': logging.INFO,
                  'debug': logging.DEBUG}


myname = os.uname()[1]


def _natural_sort_(l):
    l = [str(i) for i in l]
    convert = lambda s: int(s) if s.isdigit() else s.lower()
    alphanum_key = lambda k: [convert(c) for c in re.split(r"([0-9]+)", k)]
    return sorted(l, key=alphanum_key)


class Worker(ConsumerMixin):
    def __init__(self, connection, lockfile, iptables_file):
        self.connection = connection
        self.lockfile = lockfile
        self.iptables_file = iptables_file
        if os.path.isfile(self.lockfile):
            os.unlink(self.lockfile)

    def get_consumers(self, Consumer, channel):
        return [Consumer(queues=Queue(
            myname, Exchange(myname, type="direct"),
            routing_key=myname),
        callbacks=[self.process_task])]

    def process_task(self, body, message):
        logging.debug("TASK")
        start_time = datetime.now()
        self.iptables_save = []
        logging.debug("Received payload %s" % json.dumps(body, sort_keys=True, indent=4))

        try:
            lock = FileLock(self.lockfile.replace(".lock",""))
            lock.acquire()
            self._gen_iptables_save_(body)
            self.iptables_save.append("COMMIT\n")
            old = None
            if os.path.isfile(self.iptables_file):
                old = open(self.iptables_file, "r").readlines()
            open(self.iptables_file, "w").write("\n".join(self.iptables_save))
            new = open(self.iptables_file, "r").readlines()

            for line in difflib.unified_diff(old,new):
                logging.debug(line.rstrip())

            logging.info("Worke done")
        finally:
            lock.release()
        message.ack()

        stop_time = datetime.now()
        duration = stop_time - start_time
        logging.debug(duration)

    def _add_rule_(self, rule):
        if not len(self.iptables_save):
            self.iptables_save.append('*filter')

        if rule not in self.iptables_save:
            logging.debug(rule)
            self.iptables_save.append(rule)

    @staticmethod
    def _multiport_slice_(ports=[], step=15):
        # step => max-port per rule (iptables default => 15)
        ports   = _natural_sort_(ports)
        begin   = 0
        end     = step
        pslices = []
        while True:
            pslice = ports[begin:end]
            if len(pslice) == 0:
                break
            ranges = map(lambda x: ":" in str(x), pslice).count(True)
            if ranges == 0:
                begin += step
                end   += step
            else:
                pslice = ports[begin:end - ranges]
                begin += step - ranges
                end   += step - ranges
            pslices.append(pslice)
        return pslices

    def _gen_jumps_(self, table, name, cidr, nextjump, datacenter=False):
        try:
            if IPNetwork(nextjump).version == 6:
                netid = hashlib.md5()
                netid.update(nextjump)
                nextjump = netid.hexdigest()[:15]
            if IPNetwork(name).version == 6:
                netid = hashlib.md5()
                netid.update(name)
                name = netid.hexdigest()[:15]
        except ValueError:
            pass

        if table and name and cidr and nextjump:
            self._add_rule_(":%s-%s - [0:0]" % (table, nextjump))
            jump = "-{action} {name} -{direction} {cidr} -j {table}-{nextjump}"
            directions = { 'FORWARD': ['s', 'd'],
                           'INPUT': ['d'],
                           'OUTPUT': ['s'] }

            name = table if datacenter else "%s-%s" % (table, name)
            for direction in directions[table]:
                self._add_rule_(
                    jump.format(action='A',
                                table=table,
                                name=name,
                                direction=direction,
                                cidr=cidr,
                                nextjump=nextjump
                    )
                )

    def _get_structured_rules_(self, data=None):
        def get_chain(chain, owner):
            for ip_attrs in data.get("ips", []):
                if owner == ip_attrs.get("ip"):
                    if not ip_attrs.get("subnet"):
                        break
                    return "%s-%s" % (chain, ip_attrs.get("subnet"))
            return "%s-%s" % (chain, owner)

        st_rules = {}

        for rule in data.get("policy", []):
            table = rule.get("table")
            proto = rule.get("proto", "").lower()
            src = rule.get("src") or "0.0.0.0/0"
            src_port = rule.get("src_port") or "any"
            src_full = "%s:%s" % (src, src_port)
            dst = rule.get("dst") # or "0.0.0.0/0"
            dst_port = rule.get("dst_port") or "any"
            owner = rule.get("owner")
            policy = rule.get("policy") or "DROP"
            in_iface = rule.get("in_iface")
            out_iface = rule.get("out_iface")

            if not dst:
                if re.search("^(\d{1,3}\.){3}\d{1,3}$", rule.get("owner", "")):
                    dst = rule.get("owner")
                else:
                    dst = "0.0.0.0/0"

            if not st_rules.has_key(get_chain(table, owner)):
                st_rules[get_chain(table, owner)] = {}
            st_rules_table = st_rules[get_chain(table, owner)]
            if not st_rules_table.has_key(proto):
                st_rules_table[proto] = {}
            st_rules_proto = st_rules_table[proto]
            if not st_rules_proto.has_key(src_full):
                st_rules_proto[src_full] = {}
            st_rules_src = st_rules_proto[src_full]
            if not st_rules_src.has_key(dst):
                st_rules_src[dst] = {}
            st_rules_dst = st_rules_src[dst]
            if not st_rules_dst.has_key(policy):
                st_rules_dst[policy] = []
            st_rules_pol = st_rules_dst[policy]
            if dst_port == "any":
                if st_rules_pol != "any":
                    st_rules_dst[policy] = "any"
                    st_rules_pol = st_rules_dst[policy]
            else:
                if type(st_rules_pol) is list and dst_port not in st_rules_pol:
                    st_rules_pol.append(dst_port)
        return st_rules

    def _add_firewall_mport_rules_(self, data=None):
        for table, rule_attrs in self._get_structured_rules_(data).iteritems():
            for proto in rule_attrs.iterkeys():
                for src in rule_attrs[proto].iterkeys():
                    src_addr, src_port = src.split(":")
                    for dst_addr in rule_attrs[proto][src].iterkeys():
                        for policy in rule_attrs[proto][src][dst_addr].iterkeys():
                            dst_ports = rule_attrs[proto][src][dst_addr][policy]
                            ipt_rule = "-A %s" % table
                            if proto:
                                ipt_rule += " -p %s" % proto
                            if src_addr and src_addr != "0.0.0.0/0":
                                ipt_rule += " -s %s" % src_addr
                            if src_port and src_port != "any":
                                ipt_rule += " --sport %s" % src_port
                            if dst_addr and dst_addr != "0.0.0.0/0":
                                ipt_rule += " -d %s" % dst_addr
                            if proto == "gre":
                                self._add_rule_("%s -j %s" % (ipt_rule, policy))
                                continue
                            if type(dst_ports) is list:
                                if len(dst_ports) == 0:
                                    self._add_rule_("%s -j %s" % (ipt_rule, policy))
                                    continue
                                if len(dst_ports) == 1:
                                    self._add_rule_("%s --dport %s -j %s" % (ipt_rule, dst_ports[0], policy))
                                    continue
                                for s_dst_ports in self._multiport_slice_(dst_ports):
                                    self._add_rule_("%s -m multiport --dports %s -j %s" % (ipt_rule, ",".join(s_dst_ports), policy))
                            else:
                                self._add_rule_("%s -j %s" % (ipt_rule, policy))

    #
    # TODO: refactor this routine
    #
    def _gen_iptables_chains_(self, data):
        def rule_dzvs_block(infos):
            self._gen_jumps_(infos['table'], infos['datacenter'], infos['cidr'], infos['datacenter'], datacenter=True)
            self._gen_jumps_(infos['table'], infos['datacenter'], infos['cidr'], infos['zone'])
            self._gen_jumps_(infos['table'], infos['zone'], infos['cidr'], infos['vlan'])
            self._gen_jumps_(infos['table'], infos['vlan'], infos['cidr'], infos['cidr'])

        for rule in [ rule for rule in data.get('policy') if 'table' in rule ]:
            if ('datacenter' in data) and ('zones' in data):
                logging.debug('DC chain')
                for zone in data['zones']:
                    for vlan in zone['vlans']:
                        for subnet in vlan['subnets']:
                            if IPNetwork(subnet).version == 4:
                                infos = {'table': rule['table'],
                                         'datacenter': data['datacenter'],
                                         'cidr': subnet['cidr'],
                                         'zone': zone['zone'],
                                         'vlan': vlan['vlan']}
                            rule_dzvs_block(infos)

            if ('zone' in data) and ('vlans' in data):
                logging.debug('Zone chain')
                for vlan in data['vlans']:
                    for subnet in vlan['subnets']:
                        infos = {'table': rule['table'],
                                 'datacenter': data['datacenter'],
                                 'cidr': subnet['cidr'],
                                 'zone': data['zone'],
                                 'vlan': vlan['vlan']}
                        rule_dzvs_block(infos)

            if ('vlan' in data) and ('subnets' in data):
                logging.debug('VLAN chain')
                for subnet in data['subnets']:
                    infos = {'table': rule['table'],
                             'datacenter': data['datacenter'],
                             'cidr': subnet['cidr'],
                             'zone': data['zone'],
                             'vlan': data['vlan']}
                    rule_dzvs_block(infos)

    def _gen_iptables_save_(self, data):
        logging.debug(json.dumps(data, sort_keys=True, indent=4))
        self._gen_iptables_chains_(data)
        self._add_firewall_mport_rules_(data)


def help():
    print '%s::' % sys.argv[0]
    print '   -a action <stop|start|status|foreground>'
    print '   -u user <simplenet>'
    print '   -c config </etc/simplenet/agents.cfg>'


def main(user, config_file):
    config = ConfigParser.ConfigParser()
    config.read(config_file)

    if config.has_option('firewall','hostname'):
        global myname
        myname = config.get('firewall','hostname')

    logging.basicConfig(level=LOGGING_LEVELS.get(config.get('firewall','logging')), filename='/var/log/simplenet.log')

    with BrokerConnection(config.get('firewall','broker')) as conn:
        Worker(conn, config.get('firewall','lockfile'), config.get('firewall','iptables_file')).run()


if __name__ == '__main__':
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'a:u:c:', ['action=', 'user=', 'config='])
    except getopt.GetoptError, err:
        help()

    user = 'simplenet'
    action = 'start'
    config = '/etc/simplenet/agents.cfg'
    for o, a in opts:
        if o in ('-a', '--action'):
            action = a
        elif o in ('-u', '--user'):
            user = a
        elif o in ('-c', '--config'):
            config = a
        else:
            help()

    daemon = Daemon(name='sn-fw-agent', catch_all_log='/var/log/simplenet.log')
    if action == 'start':
        daemon.start()
        main(user, config)
    elif action == 'status':
        daemon.status()
    elif action == 'stop':
        daemon.stop()
    elif action == 'foreground':
        main(user, config)

