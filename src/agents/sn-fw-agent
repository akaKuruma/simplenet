#!/usr/bin/python

# Copyright 2012 Locaweb.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.
#
# @author: Juliano Martinez (ncode), Locaweb.
# @author: Luiz Ozaki, Locaweb.
# @author: Eduardo S. Scarpellini, Locaweb.

import ConfigParser
import difflib
import getopt
import hashlib
import json
import logging
import os
import re
import sys
from subprocess import Popen, PIPE
import shlex

from datetime import datetime
from ipaddr import IPNetwork
from lockfile import FileLock
from supay import Daemon

from kombu import Exchange, Queue
from kombu import BrokerConnection
from kombu.mixins import ConsumerMixin
from kombu.utils.debug import setup_logging


setup_logging(loglevel="INFO")
LOGGING_LEVELS = {'critical': logging.CRITICAL,
                  'error': logging.ERROR,
                  'warning': logging.WARNING,
                  'info': logging.INFO,
                  'debug': logging.DEBUG}


myname = os.uname()[1]


def _natural_sort_(l):
    l = [str(i) for i in l]
    convert = lambda s: int(s) if s.isdigit() else s.lower()
    alphanum_key = lambda k: [convert(c) for c in re.split(r"([0-9]+)", k)]
    return sorted(l, key=alphanum_key)


class Worker(ConsumerMixin):
    def __init__(self, connection, lockfile, iptables_file, logger):
        self.connection = connection
        self.lockfile = lockfile
        self.iptables_file = iptables_file
        self.logger = logger
        if os.path.isfile(self.lockfile):
            os.unlink(self.lockfile)

    def get_consumers(self, Consumer, channel):
        return [Consumer(queues=Queue(
            myname, Exchange(myname, type="direct"),
            routing_key=myname),
        callbacks=[self.process_task])]

    def _rules_diff(self):
        new = open(self.iptables_file, "r").readlines()
        p = Popen(shlex.split('/sbin/iptables-save -t filter'), stdout=PIPE, stderr=PIPE)
        old, err = p.communicate()
        old = [x.strip() for x in old.splitlines()]
        new = [x.strip() for x in new]
        new = [x.replace("-I", "-A").replace("/32", "") for x in new]
        old = [x.replace("-I", "-A").replace("/32", "") for x in old]
        old.sort()
        new.sort()

        d = difflib.Differ()

        return list(d.compare(old, new))

    def process_task(self, body, message):
        self.logger.info("TASK")
        start_time = datetime.now()
        self.iptables_save = []
        self.iptables_save.append('*filter')
        #self.logger.debug("Received payload %s" % json.dumps(body, sort_keys=True, indent=4))

        try:
            lock = FileLock(self.lockfile.replace(".lock",""))
            lock.acquire()
            self._gen_iptables_save_(body)
            self.iptables_save.append("COMMIT\n")
            open(self.iptables_file, "w").write("\n".join(self.iptables_save))
            self.late_run = []

            if body.get("modified"):
                self.logger.debug(body.get("modified"))

            for line in self._rules_diff():
                line = line.rstrip()
                if line.startswith("+ "):
                    #self.logger.info(line)
                    cmd = line[2:].replace("-A", "-I")
                    if cmd.startswith(":"):
                        cmd = cmd.split()[0][1:]
                        self._run_rule_("iptables -N %s" % cmd)
                    elif cmd.startswith("-I"):
                        self._run_rule_("iptables %s" % cmd)
                    else:
                        self.logger.debug("Ignored %s" % cmd)
                elif line.startswith("- "):
                    #self.logger.info(line)
                    cmd = line[2:].replace("-I", "-D").replace("-A", "-D")
                    if cmd.startswith(":"):
                        cmd = cmd.split()[0][1:]
                        self._run_rule_("iptables -X %s" % cmd)
                    elif cmd.startswith("-D"):
                        self._run_rule_("iptables %s" % cmd)
                    else:
                        self.logger.debug("Ignored %s" % cmd)

            self.logger.info("Re-running failed commands...")
            for line in self.late_run:
                self._run_rule_(line)

            self.logger.info("Worke done")
        finally:
            lock.release()
        message.ack()

        stop_time = datetime.now()
        duration = stop_time - start_time
        self.logger.info(duration)

    def _run_rule_(self, rule):
        ### Insanity check ###
        if rule.lower() in ['iptables -f forward', 'iptables -f input', 'iptables -f output', \
                            'iptables -x forward', 'iptables -x input', 'iptables -x output']:
            self.logger.debug("Ignored '%s'" % rule)
            return
        ######################

        self.logger.info("Running '%s'" % rule)
        status = Popen(shlex.split(rule), shell=False, stdout=PIPE, stderr=PIPE)
        stdout, stderr = status.communicate()
        if status.returncode != 0:
            if rule not in self.late_run:
                self.late_run.append(rule)
            self.logger.error("Exit code %s output: %s %s" % (status.returncode, stdout, stderr))

    def _add_rule_(self, rule):
        if rule not in self.iptables_save:
            #self.logger.debug(rule)
            self.iptables_save.append(rule)

    @staticmethod
    def _multiport_slice_(ports=[], step=15):
        # step => max-port per rule (iptables default => 15)
        ports   = _natural_sort_(ports)
        begin   = 0
        end     = step
        pslices = []
        while True:
            pslice = ports[begin:end]
            if len(pslice) == 0:
                break
            ranges = map(lambda x: ":" in str(x), pslice).count(True)
            if ranges == 0:
                begin += step
                end   += step
            else:
                pslice = ports[begin:end - ranges]
                begin += step - ranges
                end   += step - ranges
            pslices.append(pslice)
        return pslices

    def _gen_jumps_(self, table, name, cidr, nextjump, datacenter=False):
        try:
            if IPNetwork(nextjump).version == 6:
                netid = hashlib.md5()
                netid.update(nextjump)
                nextjump = netid.hexdigest()[:15]
            if IPNetwork(name).version == 6:
                netid = hashlib.md5()
                netid.update(name)
                name = netid.hexdigest()[:15]
        except ValueError:
            pass

        if table and name and cidr and nextjump:
            self._add_rule_(":%s-%s - [0:0]" % (table, nextjump))
            jump = "-{action} {name} -{direction} {cidr} -j {table}-{nextjump}"
            directions = { 'FORWARD': ['d'],
                           'INPUT': ['d'],
                           'OUTPUT': ['s'] }

            name = table if datacenter else "%s-%s" % (table, name)
            for direction in directions[table]:
                self._add_rule_(
                    jump.format(action='A',
                                table=table,
                                name=name,
                                direction=direction,
                                cidr=cidr,
                                nextjump=nextjump
                    )
                )

    def _get_structured_rules_(self, data=None):
        def get_chain(chain, owner):
            for ip_attrs in data.get("ips", []):
                if owner == ip_attrs.get("ip"):
                    if not ip_attrs.get("subnet"):
                        break
                    return "%s-%s" % (chain, ip_attrs.get("subnet"))
            return "%s-%s" % (chain, owner)

        st_rules = {}

        for rule in data.get("policy", []):
            table = rule.get("table")
            proto = rule.get("proto", "").lower() if rule.get("proto") is not None else ""
            src = rule.get("src") or "0.0.0.0/0"
            src_port = rule.get("src_port") or "any"
            src_full = "%s:%s" % (src, src_port)
            dst = rule.get("dst") #or "0.0.0.0/0"
            dst_port = rule.get("dst_port") or "any"
            owner = rule.get("owner")
            policy = rule.get("policy") or "DROP"
            in_iface = rule.get("in_iface")
            out_iface = rule.get("out_iface")

            if not dst:
                if re.search("^(\d{1,3}\.){3}\d{1,3}$", rule.get("owner", "")):
                    dst = rule.get("owner")
                else:
                    dst = "0.0.0.0/0"

            if get_chain(table, owner) not in st_rules:
                st_rules[get_chain(table, owner)] = {}
            st_rules_table = st_rules[get_chain(table, owner)]
            if proto not in st_rules_table:
                st_rules_table[proto] = {}
            st_rules_proto = st_rules_table[proto]
            if src_full not in st_rules_proto:
                st_rules_proto[src_full] = {}
            st_rules_src = st_rules_proto[src_full]
            if dst not in st_rules_src:
                st_rules_src[dst] = {}
            st_rules_dst = st_rules_src[dst]
            if policy not in st_rules_dst:
                st_rules_dst[policy] = []
            st_rules_pol = st_rules_dst[policy]
            if dst_port == "any":
                if st_rules_pol != "any":
                    st_rules_dst[policy] = "any"
                    st_rules_pol = st_rules_dst[policy]
            else:
                dst_port = dst_port.split(",")
                for dport in dst_port:
                    if type(st_rules_pol) is list and dport not in st_rules_pol:
                        st_rules_pol.append(dport)
        return st_rules

    def _add_firewall_mport_rules_(self, data=None):
        for table, rule_attrs in self._get_structured_rules_(data).iteritems():
            for proto in rule_attrs.iterkeys():
                for src in rule_attrs[proto].iterkeys():
                    src_addr, src_port = src.split(":", 1)
                    for dst_addr in rule_attrs[proto][src].iterkeys():
                        for policy in rule_attrs[proto][src][dst_addr].iterkeys():
                            dst_ports = rule_attrs[proto][src][dst_addr][policy]
                            ipt_rule = "-I %s" % table
                            if src_addr and src_addr != "0.0.0.0/0":
                                ipt_rule += " -s %s" % src_addr
                            if dst_addr and dst_addr != "0.0.0.0/0":
                                ipt_rule += " -d %s" % dst_addr
                            if proto:
                                if proto != "icmp":
                                    ipt_rule += " -p %s -m %s" % (proto, proto)
                                else:
                                    ipt_rule += " -p %s" % proto
                            if src_port and src_port != "any":
                                ipt_rule += " -m multiport --sports %s" % src_port
                            if proto == "gre":
                                self._add_rule_("%s -j %s" % (ipt_rule, policy))
                                continue
                            if type(dst_ports) is list:
                                if len(dst_ports) == 0:
                                    self._add_rule_("%s -j %s" % (ipt_rule, policy))
                                    continue
                                if len(dst_ports) == 1:
                                    self._add_rule_("%s --dport %s -j %s" % (ipt_rule, dst_ports[0], policy))
                                    continue
                                ipt_rule = ipt_rule.replace("-m udp","").replace("-m tcp", "").rstrip()
                                for s_dst_ports in self._multiport_slice_(dst_ports):
                                    self._add_rule_("%s -m multiport --dports %s -j %s" % (ipt_rule, ",".join(s_dst_ports), policy))
                            else:
                                if policy in ['ACCEPT', 'DROP', 'REJECT']:
                                    self._add_rule_("%s -j %s" % (ipt_rule, policy))

    #
    # TODO: refactor this routine
    #
    def _gen_iptables_chains_(self, data):
        def rule_dzvs_block(infos):
            self._gen_jumps_(infos['table'], infos['datacenter'], infos['cidr'], infos['datacenter'], datacenter=True)
            self._gen_jumps_(infos['table'], infos['datacenter'], infos['cidr'], infos['zone'])
            self._gen_jumps_(infos['table'], infos['zone'], infos['cidr'], infos['vlan'])
            self._gen_jumps_(infos['table'], infos['vlan'], infos['cidr'], infos['cidr'])

        rule = {}
        rule['table'] = 'FORWARD'
        for vlan in data['vlans']:
            for subnet in vlan['subnets']:
                infos = {'table': rule['table'],
                         'datacenter': vlan['datacenter'],
                         'cidr': subnet['cidr'],
                         'zone': vlan['zone'],
                         'vlan': vlan['vlan']}
                rule_dzvs_block(infos)
                [self._gen_jumps_(rule['table'], subnet['cidr'], ip['ip'], ip['ip']) for ip in subnet['ips']]

    def _gen_iptables_save_(self, data):
        #self.logger.debug(json.dumps(data, sort_keys=True, indent=4))
        self._gen_iptables_chains_(data)
        self._add_firewall_mport_rules_(data)


def help():
    print '%s::' % sys.argv[0]
    print '   -a action <stop|start|status|foreground>'
    print '   -u user <simplenet>'
    print '   -c config </etc/simplenet/agents.cfg>'


def main(user, config_file):
    config = ConfigParser.ConfigParser()
    config.read(config_file)

    if config.has_option('firewall', 'hostname'):
        global myname
        myname = config.get('firewall', 'hostname')

    logger = create_logger(config)

    lockdir = os.path.split(config.get('firewall','lockfile'))[0]
    if not os.path.isdir(lockdir):
        os.makedirs(lockdir)

    with BrokerConnection(config.get('firewall', 'broker')) as conn:
        Worker(conn, config.get('firewall', 'lockfile'), config.get('firewall', 'iptables_file'), logger).run()


def create_logger(config):
    # create logger
    logger = logging.getLogger('sn-fw-agent')
    logger.setLevel(LOGGING_LEVELS.get(config.get('firewall', 'logging')))

    formatter = logging.Formatter('%(asctime)s [%(name)s/%(levelname)s] %(message)s')

    fileHandler = logging.FileHandler('/var/log/simplenet.log')
    fileHandler.setLevel(LOGGING_LEVELS.get(config.get('firewall', 'logging')))
    fileHandler.setFormatter(formatter)

    logger.addHandler(fileHandler)

    return logger

if __name__ == '__main__':
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'a:u:c:', ['action=', 'user=', 'config='])
    except getopt.GetoptError, err:
        help()

    user = 'simplenet'
    action = 'start'
    config = '/etc/simplenet/agents.cfg'
    for o, a in opts:
        if o in ('-a', '--action'):
            action = a
        elif o in ('-u', '--user'):
            user = a
        elif o in ('-c', '--config'):
            config = a
        else:
            help()

    daemon = Daemon(name='sn-fw-agent')
    if action == 'start':
        daemon.start()
        main(user, config)
    elif action == 'status':
        daemon.status()
    elif action == 'stop':
        daemon.stop()
    elif action == 'foreground':
        main(user, config)
